<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript 学习笔记 · 人依旧♀Blog</title><meta name="description" content="JavaScript"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yijiu.ren/atom.xml" title="人依旧♀Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/renyijiu" target="_blank" class="nav-list-link">GitHub</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript 学习笔记</h1><div class="post-info">2017年4月15日</div><div class="post-content"><p>这个是自己在跟着<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰的JavaScript教程</a>学习时记录的一些笔记，这里整理一下，也算方便自己后面进行知识回顾。个人感觉这个教程作为入门了解一些专业名词和基础知识还是可以的，但是由于教程的内容包含的内容较为广，跨度较大，一些知识只是简单的叙述了一下，深入的理解和学习还是需要去查阅其他更详细的资料。</p><a id="more"></a><h4 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h4><ol><li><p>“use strict”，在strict模式下运行的JavaScript代码，强制使用<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将会导致运行错误；未声明可能导致成为全局变量，污染全局变量环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ReferenceError</span>: xxx is not defined</div></pre></td></tr></table></figure></li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol><li><p>ES6新增了一种模板字符串（若不支持，使用<code>+</code>连接字符串）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'hello world'</span>;</div><div class="line"><span class="keyword">var</span> time = <span class="string">'2017-01-01'</span>;</div><div class="line"><span class="keyword">var</span> message = <span class="string">`<span class="subst">$&#123;name&#125;</span>, 今天是<span class="subst">$&#123;time&#125;</span>!`</span>;</div><div class="line">alert(message); <span class="comment">// hello world, 今天是2017-01-01!</span></div></pre></td></tr></table></figure></li></ol><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol><li>直接给<code>Array</code>的<code>length</code>赋值，可能会导致<code>Array</code>大小的改变</li><li>通过索引赋值时，当索引超出数组大小时，同样会引起<code>Array</code>大小的改变</li></ol><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol><li>判断对象是否拥有某一属性，使用<code>in</code>操作符</li><li>使用<code>in</code>判断某一属性是否存在时，属性不一定是对象本身的，可能是继承得到的</li><li>判断一个属性是否是对象自身拥有的，而不是继承得到的，可以使用<code>hasOwnProperty()</code>方法</li></ol><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><ol><li>Javascript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>&#39;&#39;</code>视为<code>false</code>，其他值均为<code>true</code></li></ol><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ol><li><code>for...in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code></li></ol><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol><li>JavaScript函数允许传入任意个数的参数而不影响调用</li><li>关键字<code>arguments</code>只在函数内部起作用，可以获取到当前函数调用者传入的所有参数</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>在一个方法内部，<code>this</code>是一个特殊变量，始终指向当前对象</p></li><li><p>单独调用一个函数，此时，高函数的<code>this</code>指向全局变量，也就是<code>window</code></p></li><li><p>使用apply()和call()对<code>this</code>的指向进行控制，防止产生错误</p></li><li><p>利用apply()动态的改变函数的行为</p><p>假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    count += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 测试:</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'20'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'30'</span>);</div><div class="line">count; <span class="comment">// 3</span></div></pre></td></tr></table></figure></li></ol><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</div><div class="line"><span class="keyword">var</span> r;</div><div class="line">r = arr.map(<span class="built_in">parseInt</span>);</div><div class="line"></div><div class="line"><span class="comment">// 结果返回为[1, NaN, NaN]</span></div></pre></td></tr></table></figure><p>原因是在调用<code>arr.map(parseInt)</code>的时候，传给<code>map</code>的参数为三个：</p><ul><li>当前的值(currentValue) <code>// 依次是&#39;1&#39;,&#39;2&#39;,&#39;3&#39;</code></li><li>当前值的索引(currentIndex) <code>// 依次是0，1，2</code></li><li>当前的数组(currentArray) <code>// 都是[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</code></li></ul><p>而每次调用parseInt函数时，函数接受两个参数，因此只传入了两个值(<code>currentValue, currentIndex</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1，当第二个参数转换后为0或者NaN时，会被忽略</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></div></pre></td></tr></table></figure><p>所以有效的写法是<code>arr.map(function(x) { return parseInt(x)});</code></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><ol><li><code>Array</code>的<code>sort()</code>方法默认把所有元素先转换成<code>String</code>后再进行排序</li></ol><h4 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h4><ol><li><p>包装对象看上去和原来的值一样，但是他们的类型已经发生了改变，变成了<code>object</code>，并且使用<code>===</code>与原始值比较会返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure></li></ol><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>易犯的错误：<strong>箭头函数没有自己的<code>this</code></strong>，总是指向定义时所在的作用域的<code>this</code>值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure><p>上述代码中，箭头函数中的<code>this</code>并不是指向<code>a</code>这个对象的，<strong>使用的是词法作用域内的this</strong>；对象<code>a</code>并不能构建自身的作用域，不能够新建自己的<code>this</code>值，所以向上查找到达全局作用域，<code>this</code>就是指向全局作用域，而全局作用域不存在相应的属性值，因此为<code>undefined</code></p><p>下述代码中，如果使用普通函数时，输出结果就是符合预期的，这是因为</p><blockquote><p>在函数运行时，this关键字并不会指向正在运行的函数本身，而是指向调用该函数的对象</p></blockquote><p>也就是<code>a.bar()</code>函数执行时作用域绑到了<code>a</code>对象，<code>this</code>就是指向了<code>a</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = a.bar;</div><div class="line">c(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>此时调用函数<code>bar</code>的是<code>window</code>对象，所以函数<code>bar</code>的<code>this</code>被指向了<code>window</code>，而<code>window</code>不存在<code>foo</code>属性，所以结果是<code>undefined</code></p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><ol><li>JavaScript的原型链和Java的Class的区别是，JavaScript没有<code>Class</code>的概念，所有的对象都是实例，所谓的<strong>继承关系不过是把一个对象的原型指向另外一个对象而已</strong>。</li><li><code>prototype</code>是<strong>函数</strong>的一个属性(每个函数都有一个<code>prototype</code>属性)，这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。</li><li><code>__proto__</code>是一个对象拥有的内置属性，(<strong>请注意：<code>prototype</code>是函数的内置属性，<code>__proto__</code>是对象的内置属性</strong>)，是JS内部使用寻找原型链的属性。</li></ol><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><ol><li><p>如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变慢，所以不要把原型链搞得太长</p></li><li><p>使用<code>new</code>，变成了一个构造函数，他绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>)；</div><div class="line">xiaoming.name; <span class="comment">// "小明"</span></div><div class="line">xiaoming.hello(); <span class="comment">// "Hello,小明!"</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaohong = <span class="keyword">new</span> Student(<span class="string">"小红"</span>)；</div><div class="line">xiaohong.name; <span class="comment">// "小红"</span></div><div class="line"></div><div class="line"><span class="comment">// 注意这里</span></div><div class="line">xiaohong.hello; <span class="comment">// function Student/this.hello()</span></div><div class="line">xiaoming.hello; <span class="comment">// function Student/this.hello()</span></div><div class="line">xiaohong.hello === xiaoming.hello <span class="comment">// false</span></div></pre></td></tr></table></figure><p>从上述代码可以看出，<code>xiaoming.hello</code>和<code>xiaohong.hello</code>都是函数，但是它们是不同的函数，虽然函数名称和代码是相同的！</p><p>所以，当我们通过<code>new Student()</code>创建了较多对象时，每个对象都有一个自己的<code>hello</code>函数，这样子来说是比较耗费内存的，实际上只需要共享同一个函数就可以了，这样子可以节省资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Hello,"</span> + <span class="keyword">this</span>.name + <span class="string">"!"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><em>为了区分普通函数和构造函数，按照约定，构造函数首字母应该大写，而普通函数首字母应该小写</em></p></li></ol><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><ol><li>定义新的构造函数，并在内部用<code>call()</code>调用希望”继承”的构造函数，动态修改<code>this</code></li><li>借助中间函数<code>F</code>实现原型链继承（可以通过封装的<code>inherits</code>函数完成）</li><li>继续在新的构造函数上的原型上定义新的方法</li></ol><h4 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h4><h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ol><li><code>location</code>对象表示当前页面的URL信息</li><li>加载一个新页面，可以调用<code>location.assign()</code></li><li>重新加载当前页面，调用<code>location.reload()</code></li></ol><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h5><ol><li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑</li><li>插件函数最后要<code>return this</code>，以实现链式调用</li><li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginNane&gt;.defaults</code>上</li><li>用户在调用时可以传入设定值以覆盖默认值</li></ol><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ol><li>在Node环境中，一个.js文件就称为一个模块(module)</li><li>提高了代码的可维护性</li><li>模块的名字就是文件名（去掉<code>.js</code>的后缀）</li><li>模块中对外输出变量，用<code>module.exports = variable;</code></li><li>引入其他模块输出的对象，用<code>var foo = require(&#39;other_module&#39;);</code></li></ol><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><ol><li>流的特点是数据是有序的，而且必须是依次读取，或者依次写入</li><li><code>pipe()</code>把一个文件流和另一个文件流串起来，这样子源文件的所有数据就自动写入到目标文件了</li></ol><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ol><li><code>request</code>对象封装了HTTP请求，调用<code>request</code>对象的属性和方法就可以拿到所有的HTTP请求的信息</li><li><code>response</code>对象封装了HTTP响应，操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器</li></ol><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ol><li>关注Model的变化，让MVVM框架取去自动更新DOM的状态</li><li>单向绑定：把Model绑定到View，当我们使用JavaScript代码更新Model时，View会自动更新</li><li>双向绑定： 当用户更新了View，Model的数据也会自动被更新</li><li>让Model和DOM结构保持同步</li><li>优势是前端逻辑复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面逻辑</li></ol></div></article></div></section><footer><div class="paginator"><a href="/2017/04/05/node-js开发指南-学习笔记/" class="prev">上一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://yijiu.ren">人依旧</a>, Live For Dream, Dream For Love.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>!function(e,t,a,n,c,o){e.GoogleAnalyticsObject=n,e[n]||(e[n]=function(){(e[n].q=e[n].q||[]).push(arguments)}),e[n].l=+new Date,c=t.createElement(a),o=t.getElementsByTagName(a)[0],c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script","ga"),ga("create","UA-78885477-1","auto"),ga("send","pageview")</script></body></html>