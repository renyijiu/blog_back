<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Action Cable的使用分析 · 人依旧♀Blog</title><meta name="description" content="Action Cable的使用分析 - 人依旧"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yijiu.ren/atom.xml" title="人依旧♀Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/renyijiu" target="_blank" class="nav-list-link">GitHub</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Action Cable的使用分析</h1><div class="post-info">2016年10月26日</div><div class="post-content"><p>Action Cable是Rails5中为了类似聊天、通知之类的实时通讯而引入的新功能，是这个版本的一个重大特性吧，也可以说是基于websocket进行的一个服务。下面通过ruby china中对Action Cable的使用进行一定的解释。<a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>轮询：客户端采用AJAX向服务器发送请求，服务器接收到请求后立即返回响应信息并关闭连接。</li><li>长轮询：客户端采用AJAX向服务器发送请求，服务器保持连接，等到有新消息时返回响应信息并关闭连接，客户端处理完响应信息后发送新的请求。</li><li>长连接：客户端向服务器发送请求，建立一条持久化TCP连接，服务器写入数据后并不会关闭连接，之后的数据返回仍旧使用这条连接，客户端发起新请求时也是使用这条连接。但其中使用的是http请求，头部带有较多信息，相对来说，会有部分浪费。值得一说的是，<strong>由于HTTP协议特性，它是被动的，一个request只能有一个response，而response是被动的，不能够主动发起</strong></li><li>websocket：一种基于TCP的协议，可以进行双向通信。在握手阶段，使用http协议发送一个请求，头部带有下列类似信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Connection:Upgrade</div><div class="line">Sec-WebSocket-Extensions:permessage-deflate; client_max_window_bits</div><div class="line">Sec-WebSocket-Key:SbBf9EC5xV/w90MBFG9ptg==</div><div class="line">Sec-WebSocket-Protocol:actioncable-v1-json, actioncable-unsupported</div><div class="line">Sec-WebSocket-Version:13</div><div class="line">Upgrade:websocket</div></pre></td></tr></table></figure><p>这样子的信息，告诉服务器端我要使用websocket协议，如果服务器支持websocket协议，会返回一个确认信息，表示已经使用websocket协议通信，如下显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Connection:upgrade</div><div class="line">Sec-WebSocket-Accept:......</div><div class="line">Sec-WebSocket-Protocol:actioncable-v1-json</div><div class="line">Upgrade:websocket</div></pre></td></tr></table></figure><p>在这里之后就与http协议没有关系了，而这个连接的状态码应该是101，这也是一个协议转换的表现。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Action Cable就是基于websocket开发的一个实时通讯的全栈解决方案，下面使用Ruby China的源码进行分析，对Action Cable的使用进行一定的说明，这个分析的话是从客户端请求开始解释，可能与实际开发过程不太一致。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>Action Cable默认提供了一个文件<code>app/assets/javascripts/cable.js</code>可以用来开启websocket服务，而Ruby China中对代码进行了整合，放在了<code>app/assets/javascripts/app.coffee</code>这个文件中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="comment">#= require action_cable</span></div><div class="line">......</div><div class="line">window.App =</div><div class="line">  <span class="symbol">cable:</span> ActionCable.createConsumer()</div><div class="line">......</div></pre></td></tr></table></figure><p>这里的话调用后客户端就会新建一个websocket连接，其中在<code>layout/application.html.erb</code>文件中头部添加了 <code>&lt;%= action_cable_meta_tag %&gt;</code> 的标签，函数源码如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">action_cable_meta_tag</span></span></div><div class="line">  tag <span class="string">"meta"</span>, <span class="symbol">name:</span> <span class="string">"action-cable-url"</span>, <span class="symbol">content:</span> (</div><div class="line">    ActionCable.server.config.url <span class="params">||</span></div><div class="line">    ActionCable.server.config.mount_path <span class="params">||</span></div><div class="line">    raise(<span class="string">"No Action Cable URL configured -- please configure this at config.action_cable.url"</span>)</div><div class="line">  )</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>这个会生成一个html标签，包含了<code>ActionCable.server</code>的url地址，被<code>createConsumer</code>函数利用。</p><p>这里使用Ruby China中新回复提醒的功能进行解释，在<code>app/assets/javascripts/topics.coffee</code>中定义了下列函数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">initialize: <span class="function"><span class="params">(opts)</span> -&gt;</span></div><div class="line">  @initCableUpdate()</div><div class="line">  ......</div><div class="line"></div><div class="line"></div><div class="line">initCableUpdate: <span class="function"><span class="params">()</span> -&gt;</span></div><div class="line">  self = @</div><div class="line"></div><div class="line">  <span class="keyword">if</span> <span class="keyword">not</span> Topics.topic_id</div><div class="line">    <span class="keyword">return</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> !<span class="built_in">window</span>.repliesChannel</div><div class="line">    <span class="built_in">console</span>.log <span class="string">"init repliesChannel"</span></div><div class="line">    <span class="built_in">window</span>.repliesChannel = App.cable.subscriptions.create <span class="string">'RepliesChannel'</span>,</div><div class="line">      connected: <span class="function">-&gt;</span></div><div class="line">        setTimeout =&gt;</div><div class="line">          @followCurrentTopic()</div><div class="line">          $(<span class="built_in">window</span>).<span class="literal">on</span> <span class="string">'unload'</span>, <span class="function">-&gt;</span> <span class="built_in">window</span>.repliesChannel.unfollow()</div><div class="line">          $(<span class="built_in">document</span>).<span class="literal">on</span> <span class="string">'page:change'</span>, <span class="function">-&gt;</span> <span class="built_in">window</span>.repliesChannel.followCurrentTopic()</div><div class="line">        , <span class="number">1000</span></div><div class="line"></div><div class="line">      received: <span class="function"><span class="params">(json)</span> =&gt;</span></div><div class="line">        <span class="keyword">if</span> json.user_id == App.current_user_id</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        <span class="keyword">if</span> json.action == <span class="string">'create'</span></div><div class="line">          <span class="keyword">if</span> App.windowInActive</div><div class="line">            @updateReplies()</div><div class="line">          <span class="keyword">else</span></div><div class="line">            $(<span class="string">".notify-updated"</span>).show()</div><div class="line"></div><div class="line">      followCurrentTopic: <span class="function">-&gt;</span></div><div class="line">        @perform <span class="string">'follow'</span>, topic_id: Topics.topic_id</div><div class="line"></div><div class="line">      unfollow: <span class="function">-&gt;</span></div><div class="line">        @perform <span class="string">'unfollow'</span></div></pre></td></tr></table></figure><p><code>App.cable.subscriptions.create</code>这个操作会向RepliesChannel这个频道产生一个新的订阅，connected定义了连接时进行的操作，先执行<code>followCurrentTopic</code>这个函数，而根据这个函数的定义是去调用<code>RepliesChannel#follow</code>，这个类似于远程调用，调用的是服务端的函数，（服务端会主动暴露这些公开的方法，因此可以通过<code>perform</code>方法去调用），其中<code>follow</code>函数的定义如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(data)</span></span></div><div class="line">  stop_all_streams</div><div class="line">  stream_from <span class="string">"topics/<span class="subst">#&#123;data[<span class="string">'topic_id'</span>]&#125;</span>/replies"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>stream_from 函数查代码显示<br><code>logger.info &quot;#{self.class.name} is streaming from #{broadcasting}&quot;</code>，<br>ActionCable 收发信息的最小单位是 stream ，这个函数主要是对连接下的stream进行标记。</p><p>上述是客户端对服务器端进行了频道的订阅，当然订阅后也可以通过这样调用<br><code>window.repliesChannel.send({ sent_by: &quot;test&quot;, body: &quot;This is a test.&quot; })</code>向服务器端发送消息，服务器端需要设定<code>received</code>函数进行接收，Ruby China没有用到这个功能，所以没有定义。</p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><p>首先在<code>app/channels/application_cable/connection.rb</code>这个文件中对客户端的连接进行认证</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">identified_by <span class="symbol">:current_user_id</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span></span></div><div class="line">  <span class="keyword">self</span>.current_user_id = find_verified_user_id</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">protected</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_verified_user_id</span></span></div><div class="line">  cookies.signed[<span class="symbol">:user_id</span>] <span class="params">||</span> <span class="literal">nil</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>当用户没有登录时可以选择拒绝连接<code>reject_unauthorized_connection</code>，这里没有这么做。</p><p>然后呢在<code>app/channels/application_cable/channel.rb</code>中定义<code>ApplicationCable::Channel</code>类，在这个里面可以写一些多个channel共用的代码。剩下的就是定义自己需要使用的channel，Ruby China中定义了<code>notifications_channel</code>和<code>replies_channel</code>。</p><p>然后呢，当用户对一个topic进行回复之后，在数据成功创建后，<code>app/models/reply.rb</code>model中定义的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">after_commit <span class="symbol">:async_create_reply_notify</span>, <span class="symbol">on:</span> <span class="symbol">:create</span>, <span class="symbol">unless:</span> -&gt; &#123; system_event? &#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_create_reply_notify</span></span></div><div class="line">  NotifyReplyJob.perform_later(id)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>这里使用了activejob进行处理，<code>perform_later</code>会调用<code>perform</code>函数，查看<code>app/jobs/notify_reply_job.rb</code>的代码可以发现<br><code>NotifyReplyJob#perform</code>又调用了一个类方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform</span><span class="params">(reply_id)</span></span></div><div class="line">  Reply.notify_reply_created(reply_id)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>而其中<code>notify_reply_created</code>函数定义如下，部分省略</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">notify_reply_created</span><span class="params">(reply_id)</span></span></div><div class="line">  ......</div><div class="line">  <span class="keyword">self</span>.broadcast_to_client(reply)</div><div class="line"></div><div class="line">  <span class="literal">true</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">broadcast_to_client</span><span class="params">(reply)</span></span></div><div class="line">  ActionCable.server.broadcast(<span class="string">"topics/<span class="subst">#&#123;reply.topic_id&#125;</span>/replies"</span>, <span class="symbol">id:</span> reply.id, <span class="symbol">user_id:</span> reply.user_id, <span class="symbol">action:</span> <span class="symbol">:create</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>通过方法调用可以发现，最后使用<code>ActionCable.server.broadcast</code>进行消息的广播，向客户端传播消息。</p><h4 id="回到客户端"><a href="#回到客户端" class="headerlink" title="回到客户端"></a>回到客户端</h4><p>再回到客户端，前面的coffee代码中定义了接收操作</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">received:</span> (json) =&gt;</div><div class="line">  <span class="keyword">if</span> json.user_id == App.current_user_id</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  <span class="keyword">if</span> json.action == <span class="string">'create'</span></div><div class="line">    <span class="keyword">if</span> App.windowInActive</div><div class="line">      @updateReplies()</div><div class="line">    <span class="keyword">else</span></div><div class="line">      $(<span class="string">".notify-updated"</span>).show()</div></pre></td></tr></table></figure><p>对传输数据进行一些验证，然后将<code>class=&quot;notify-updated&quot;</code>的div模块显示，而模块代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notify-updated"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"update"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-bell-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span>有新回复！<span class="tag">&lt;/<span class="name">b</span>&gt;</span>点击这里立即载入<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>最终就得到了下图的效果，当有新回复时，处于当前页面的用户会收到提醒。<img src="/images/new_reply.png" alt=""></p><p>最后附上一张曹力在RubyConf China 2016上关于 <strong><a href="https://speakerdeck.com/shiningray/actioncablehe-shi-shi-jiao-hu" target="_blank" rel="external">ActionCable 与实时交互</a></strong>中的PPT的一张截图，全面的解析了整体过程<img src="/images/actioncable.png" alt=""></p></div></article></div></section><footer><div class="paginator"><a href="/2016/06/07/写在毕业之际/" class="prev">上一篇</a><a href="/2016/10/30/Rails中自定义错误页面/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://yijiu.ren">人依旧</a>, Live For Dream, Dream For Love.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>!function(e,t,a,n,c,o){e.GoogleAnalyticsObject=n,e[n]||(e[n]=function(){(e[n].q=e[n].q||[]).push(arguments)}),e[n].l=+new Date,c=t.createElement(a),o=t.getElementsByTagName(a)[0],c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script","ga"),ga("create","UA-78885477-1","auto"),ga("send","pageview")</script></body></html>